# A Narrative for Users

This document explores the `OnStomp` API through a narrative aimed at end
users of the library.  It will start with the basics and work through the
available features through exposition and examples. It may be helpful to
review the [STOMP specification](http://stomp.github.com/index.html) before
diving into this document.

## Creating a STOMP Client

Creating a {OnStomp::Client client} connection to a STOMP broker is done
by creating a new client and connecting it. This can be accomplished a few
different ways.

    !!!ruby
    # The common way
    client = OnStomp::Client.new("stomp://host.example.org")
    client.connect
    
    # A short-cut
    client = OnStomp.connect "stomp://host.example.org"
    
The {OnStomp.connect} method creates a new client instance and immediately
calls {OnStomp::Client#connect connect} on it. This method is also aliased as
`open`, so use the verbiage you're most comfortable with.

Once connected, frames can be sent to the STOMP broker through a series of
convenient (and fairly common amongst most STOMP clients) methods such as
{OnStomp::Interfaces::FrameMethods#send send},
{OnStomp::Interfaces::FrameMethods#subscribe subscribe} and 
{OnStomp::Interfaces::FrameMethods#ack ack}. A full list of the frame methods can
be found in the documentation for the {OnStomp::Interfaces::FrameMethods}
mixin.

So, let's send some SEND frame to the broker:

    !!!ruby
    client.send '/queue/test', 'Hello World!'
    client.send '/queue/test', 'Persist this, please.', :persistent => true
    
Most frame-generating methods treat the last parameter as a hash of headers
to include with the generated frame. The only exception to this is the
{OnStomp::Interfaces::FrameMethods#beat heart-beat} frame, which has no
command, headers or body.

## Subscriptions and Receipts

### Subscribing: Send me stuff, and maybe I'll tell you when I got it.

Subscriptions in `onstomp` are pretty much just blocks that get called every
time a MESSAGE frame is received that matches a previously sent SUBSCRIBE frame.

To set up a subscription, just pass a block to the
{OnStomp::Interfaces::FrameMethods#subscribe subscribe} method:

    !!!ruby
    client.subscribe '/queue/test' do |msg|
      # Invoked every time the broker delivers a MESSAGE frame for the
      # SUBSCRIBE frame generated by this method call.
      puts "Got a message: #{msg.body}"
    end
    
The STOMP protocol supports a few different ways of acknowledging that MESSAGE
frames were received, depending upon the protocol version. STOMP 1.0
connections support automatic acknowledgment (the default behavior) and
client-side message acknowledgment.  STOMP 1.1 adds a `client-individual` mode
that may behave differently depending upon the broker you are using.  It is
considered incorrect for a client to acknowledge MESSAGE frames with ACK
frames if the subscription is operating in `auto` mode. To set the ack mode
of a subscription, include an `:ack` header in your call to
{OnStomp::Interfaces::FrameMethods#subscribe subscribe}:

    !!!ruby
    # Technically, this isn't needed as auto is the default ack mode
    client.subscribe '/queue/test', :ack => 'auto' do |msg|
      # process the MESSAGE frame
      # ...
    end
    
    # Set the subscription's ack mode to client
    client.subscribe '/queue/test', :ack => 'client' do |msg|
      # process the MESSAGE frame
      # ...
      # Tell the broker that the MESSAGE frame was processed
      client.ack msg
    end
    
    # Set the subscription's ack mode to client-individual
    client.subscribe '/queue/test', :ack => 'client-individual' do |msg|
      # process the MESSAGE frame
      # ...
      # Tell the broker that the MESSAGE frame was NOT processed
      client.nack msg
    end
    
The difference between `:ack => 'client'` and `:ack => 'client-individual`
largely depends upon the STOMP broker. Apache's [ActiveMQ](http://activemq.apache.org/)
treats ACK frames received for a MESSAGE frame as "cumulative acknowledgements,"
that is an ACK frame acknowledges the MESSAGE it was sent for and all previous
MESSAGE frames sent from the broker to the client.  The STOMP 1.1 spec
clarified the expected behavior brokers should exhibit when receiving an ACK
frame, and a `client-individual` ack mode specifies that each MESSAGE frame
will be acknowledged with its own ACK (or NACK) frame. There may be brokers
that behave this way when using a `client` ack mode, so what happens when
you ACK a MESSAGE in `client` mode depends heavily on the broker being used.

The NACK frame was introduced in the STOMP 1.1 spec and gives the client a
way to tell the broker that it did not successfully process a MESSAGE. It is
very similar in structure to an ACK frame, which makes sense it is little
more than a "Not ACK".

### Receipts: Did you get that thing I sent you?

Most frames a client sends to a STOMP broker can be receipted (ie: the
client can instruct the broker to send a RECEIPT frame after it receives
the original frame.) The two exceptions to this are heart-beat frames (as
mentioned previously, heart-beats really aren't frames) and CONNECT
frames.  The client does this by including a `receipt` header that specifies
an receipt ID for the frame being sent, the broker will in turn deliver a
RECEIPT frame with a matching `receipt-id` header. In OnStomp, requesting a
receipt for a SEND frame is as easy as including a block with your call to
{OnStomp::Interfaces::FrameMethods#send send}:

    !!!ruby
    client.send '/queue/test', 'Did you get this?' do |r|
      puts "Got my receipt: #{r[:'receipt-id']}"
    end
    
To request receipts for other types of frames, see
{file:docs/UserNarrative.md#with\_receipt with\_receipt} subsection of
{file:docs/UserNarrative.md#Scopes Scopes}.

## Scopes

Sometimes you want to do the same stuff with a series of frames, and that's
why we have {OnStomp::Components::Scopes scopes}.

### with_headers

A {OnStomp::Components::Scopes::HeaderScope header} scope is a convenient way to
apply a common set of headers to a series of frames. You can create a new
header scope from a client by calling
{OnStomp::Components::Scopes#with\_headers with\_headers}:

    !!!ruby
    scope = client.with_headers :persistent => true, :'content-type' => 'text/plain'
    scope.send '/queue/test', 'walks in to the room'
    scope.send '/queue/test', 'feels like a big balloon', :persitent => false
    scope.send '/queue/test', 'big girls, you are beautiful'
    
All of the SEND frames generated will have a `content-type` header with a value
of `text/plain`. The first and last frames will also have a header of
`persistent` with a value of `true`; however, the middle frame's `persistent`
header will have a value of `false`. As illustrated, headers specified on
the frame-generating methods will override those defined for the scope.

If you want to apply the headers to a series of frames in one swoop and don't
need to keep a `scope` variable around, you can pass a block to `with_headers`:

    !!!ruby
    client.with_headers :persistent => true, :'content-type' => 'text/plain' do |h|
      h.send '/queue/test', 'walks in to the room'
      h.send '/queue/test', 'feels like a big balloon', :persitent => false
      h.send '/queue/test', 'big girls, you are beautiful'
    end
    
This code sample produces the same results as the earlier example but without
the need to keep track of the header scope instance.

### with_receipt

A {OnStomp::Components::Scopes::ReceiptScope receipt} scope is a convenient way
to use the same receipt callback for multiple receipts. You can create a new
receipt scope from a client by calling
{OnStomp::Components::Scopes#with\_receipt with\_receipt} with the shared
callback:
    
    !!!ruby
    scope = client.with_receipt do |r|
      puts "Got my receipt!"
    end
    
    scope.send '/queue/test', 'walks in to the room'
    scope.subscribe '/queue/test2'
    
This code sample will instruct the broker to create RECEIPT frames for client
generated SEND and SUBSCRIBE frames. The receipt scope takes care of generating
unique values for the `receipt` header of each frame. If you only need the
receipt handler for one frame, you can use a bit of method chaining:

    !!!ruby
    client.with_receipt do |r|
      puts "Broker got DISCONNECT"
    end.disconnect
    
### transaction

A {OnStomp::Components::Scopes::TransactionScope transaction} scope is a little
more complicated than the previous scopes, but only marginally so. This scope
is useful if you want to deliver some frames as part of a transaction, but
don't want to be bothered with managing `transaction` headers manually.
The simplest way to use a transaction scope is to hand it a block you want
handled transactionally:

    client.transaction do |t|
      
    end

## Events and Callbacks

## Body Encodings

## The `open-uri` Angle

## Failing Over

## Appendix: Technical Things and Gotchas
